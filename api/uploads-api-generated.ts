/* tslint:disable */
/* eslint-disable */
/*
Discourse API Documentation

This page contains the documentation on how to use Discourse through API calls.

> Note: For any endpoints not listed you can follow the
[reverse engineer the Discourse API](https://meta.discourse.org/t/-/20576)
guide to figure out how to use an API endpoint.

### Request Content-Type

The Content-Type for POST and PUT requests can be set to `application/x-www-form-urlencoded`,
`multipart/form-data`, or `application/json`.

### Endpoint Names and Response Content-Type

Most API endpoints provide the same content as their HTML counterparts. For example
the URL `/categories` serves a list of categories, the `/categories.json` API provides the
same information in JSON format.

Instead of sending API requests to `/categories.json` you may also send them to `/categories`
and add an `Accept: application/json` header to the request to get the JSON response.
Sending requests with the `Accept` header is necessary if you want to use URLs
for related endpoints returned by the API, such as pagination URLs.
These URLs are returned without the `.json` prefix so you need to add the header in
order to get the correct response format.

### Authentication

Some endpoints do not require any authentication, pretty much anything else will
require you to be authenticated.

To become authenticated you will need to create an API Key from the admin panel.

Once you have your API Key you can pass it in along with your API Username
as an HTTP header like this:

```
curl -X GET \"http://127.0.0.1:3000/admin/users/list/active.json\" \\
-H \"Api-Key: 714552c6148e1617aeab526d0606184b94a80ec048fc09894ff1a72b740c5f19\" \\
-H \"Api-Username: system\"
```

and this is how POST requests will look:

```
curl -X POST \"http://127.0.0.1:3000/categories\" \\
-H \"Content-Type: multipart/form-data;\" \\
-H \"Api-Key: 714552c6148e1617aeab526d0606184b94a80ec048fc09894ff1a72b740c5f19\" \\
-H \"Api-Username: system\" \\
-F \"name=89853c20-4409-e91a-a8ea-f6cdff96aaaa\" \\
-F \"color=49d9e9\" \\
-F \"text_color=f0fcfd\"
```

### Boolean values

If an endpoint accepts a boolean be sure to specify it as a lowercase
`true` or `false` value unless noted otherwise.


The version of the OpenAPI document: latest


NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
import { fromBuffer } from "file-type/browser"
const FormData = require("form-data")
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { UploadsAbortMultipartUploadRequest } from '../models';
// @ts-ignore
import { UploadsAbortMultipartUploadResponse } from '../models';
// @ts-ignore
import { UploadsCompleteExternalUploadRequest } from '../models';
// @ts-ignore
import { UploadsCompleteExternalUploadResponse } from '../models';
// @ts-ignore
import { UploadsCompleteMultipartUploadRequest } from '../models';
// @ts-ignore
import { UploadsCompleteMultipartUploadResponse } from '../models';
// @ts-ignore
import { UploadsCreateMultipartExternalUploadRequest } from '../models';
// @ts-ignore
import { UploadsCreateMultipartExternalUploadResponse } from '../models';
// @ts-ignore
import { UploadsCreateNewUploadRequest } from '../models';
// @ts-ignore
import { UploadsCreateNewUploadResponse } from '../models';
// @ts-ignore
import { UploadsGeneratePresignedUrlsForMultipartPartsRequest } from '../models';
// @ts-ignore
import { UploadsGeneratePresignedUrlsForMultipartPartsResponse } from '../models';
// @ts-ignore
import { UploadsInitiateDirectExternalUploadRequest } from '../models';
// @ts-ignore
import { UploadsInitiateDirectExternalUploadRequestMetadata } from '../models';
// @ts-ignore
import { UploadsInitiateDirectExternalUploadResponse } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * UploadsApi - axios parameter creator
 * @export
 */
export const UploadsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint aborts the multipart upload initiated with /create-multipart. This should be used when cancelling the upload. It does not matter if parts were already uploaded into the external storage provider.  You must have the correct permissions and CORS settings configured in your external provider. We support AWS S3 as the default. See:  https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.  An external file store must be set up and `enable_direct_s3_uploads` must be set to true for this endpoint to function.  
         * @summary Abort multipart upload
         * @param {UploadsAbortMultipartUploadRequest} [uploadsAbortMultipartUploadRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        abortMultipartUpload: async (uploadsAbortMultipartUploadRequest?: UploadsAbortMultipartUploadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/uploads/abort-multipart.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: uploadsAbortMultipartUploadRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/uploads/abort-multipart.json',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(uploadsAbortMultipartUploadRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Completes an external upload initialized with /get-presigned-put. The file will be moved from its temporary location in external storage to a final destination in the S3 bucket. An Upload record will also be created in the database in most cases.  If a sha1-checksum was provided in the initial request it will also be compared with the uploaded file in storage to make sure the same file was uploaded. The file size will be compared for the same reason.  You must have the correct permissions and CORS settings configured in your external provider. We support AWS S3 as the default. See:  https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.  An external file store must be set up and `enable_direct_s3_uploads` must be set to true for this endpoint to function.  
         * @summary Completes a direct external upload
         * @param {UploadsCompleteExternalUploadRequest} [uploadsCompleteExternalUploadRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeExternalUpload: async (uploadsCompleteExternalUploadRequest?: UploadsCompleteExternalUploadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/uploads/complete-external-upload.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: uploadsCompleteExternalUploadRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/uploads/complete-external-upload.json',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(uploadsCompleteExternalUploadRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Completes the multipart upload in the external store, and copies the file from its temporary location to its final location in the store. All of the parts must have been uploaded to the external storage provider. An Upload record will be completed in most cases once the file is copied to its final location.  You must have the correct permissions and CORS settings configured in your external provider. We support AWS S3 as the default. See:  https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.  An external file store must be set up and `enable_direct_s3_uploads` must be set to true for this endpoint to function.  
         * @summary Complete multipart upload
         * @param {UploadsCompleteMultipartUploadRequest} [uploadsCompleteMultipartUploadRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeMultipartUpload: async (uploadsCompleteMultipartUploadRequest?: UploadsCompleteMultipartUploadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/uploads/complete-multipart.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: uploadsCompleteMultipartUploadRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/uploads/complete-multipart.json',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(uploadsCompleteMultipartUploadRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a multipart upload in the external storage provider, storing a temporary reference to the external upload similar to /get-presigned-put.  You must have the correct permissions and CORS settings configured in your external provider. We support AWS S3 as the default. See:  https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.  An external file store must be set up and `enable_direct_s3_uploads` must be set to true for this endpoint to function.  
         * @summary Creates a multipart external upload
         * @param {UploadsCreateMultipartExternalUploadRequest} [uploadsCreateMultipartExternalUploadRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMultipartExternalUpload: async (uploadsCreateMultipartExternalUploadRequest?: UploadsCreateMultipartExternalUploadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/uploads/create-multipart.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: uploadsCreateMultipartExternalUploadRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/uploads/create-multipart.json',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(uploadsCreateMultipartExternalUploadRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates an upload
         * @param {string} type 
         * @param {number} [userId] required if uploading an avatar
         * @param {boolean} [synchronous] Use this flag to return an id and url
         * @param {Uint8Array | File | buffer.File} [file] 
         * @param {UploadsCreateNewUploadRequest} [uploadsCreateNewUploadRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewUpload: async (type: string, userId?: number, synchronous?: boolean, file?: Uint8Array | File | buffer.File, uploadsCreateNewUploadRequest?: UploadsCreateNewUploadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('createNewUpload', 'type', type)
            const localVarPath = `/uploads.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            const addFormParam = async (name: string, data: any, isBinary: boolean, isPrimitiveType: boolean) => {
                if (isBinary) {
                    if (data instanceof Uint8Array) {
                        // Handle Buffer data
                        const filetype = await fromBuffer(data)
                        const filename = filetype === undefined ? name : `${name}.${filetype.ext}`
                        localVarFormParams.append(name, data as any, filename);
                    } else if ("name" in data) {
                        // File instances in browsers and Node.js have the
                        // "name" property "Duck typing" files to handle browser
                        // File class or Node.js File class
                        // Web: https://developer.mozilla.org/en-US/docs/Web/API/File
                        // Node.js: https://nodejs.org/api/buffer.html#new-bufferfilesources-filename-options
                        if (isBrowser()) {
                            // FormData in browser can accept File/Blob directly
                            localVarFormParams.append(name, data, data.name);
                        } else {
                            // FormData in Node.js can only accept raw Buffer so convert before passing
                            const bytes = await data.arrayBuffer()
                            const buffer = Buffer.from(bytes)
                            localVarFormParams.append(name, buffer, data.name);
                        }
                    }
                } else {
                    if (isPrimitiveType) {
                        /**
                         * FormData can only accept string or Blob so we need to convert
                         * non-string primitives to string. We also need to convert
                         */
                        if (typeof data === "object") {
                          localVarFormParams.append(name, JSON.stringify(data));
                        } else {
                          localVarFormParams.append(name, data);
                        }
                    } else {
                        if (isBrowser()) {
                            localVarFormParams.append(name, new Blob([JSON.stringify(data)], { type: "application/json" }))
                        } else {
                            localVarFormParams.append(name, JSON.stringify(data), { type: "application/json", filename: "data.json" });
                        }
                    }
                }
            }
            if (!isBrowser()) Object.assign(localVarHeaderParameter, localVarFormParams.getHeaders());


            if (type !== undefined) {
                await addFormParam('type', type, false, true)
            }
    
            if (userId !== undefined) {
                await addFormParam('user_id', userId, false, true)
            }
    
            if (synchronous !== undefined) {
                await addFormParam('synchronous', synchronous, false, true)
            }
    
            if (file !== undefined) {
                await addFormParam('file', file, true, true)
            }
    
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;
            requestBeforeHook({
                requestBody: uploadsCreateNewUploadRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/uploads.json',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Multipart uploads are uploaded in chunks or parts to individual presigned URLs, similar to the one generated by /generate-presigned-put. The part numbers provided must be between 1 and 10000. The total number of parts will depend on the chunk size in bytes that you intend to use to upload each chunk. For example a 12MB file may have 2 5MB chunks and a final 2MB chunk, for part numbers 1, 2, and 3.  This endpoint will return a presigned URL for each part number provided, which you can then use to send PUT requests for the binary chunk corresponding to that part. When the part is uploaded, the provider should return an ETag for the part, and this should be stored along with the part number, because this is needed to complete the multipart upload.  You must have the correct permissions and CORS settings configured in your external provider. We support AWS S3 as the default. See:  https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.  An external file store must be set up and `enable_direct_s3_uploads` must be set to true for this endpoint to function.  
         * @summary Generates batches of presigned URLs for multipart parts
         * @param {UploadsGeneratePresignedUrlsForMultipartPartsRequest} [uploadsGeneratePresignedUrlsForMultipartPartsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generatePresignedUrlsForMultipartParts: async (uploadsGeneratePresignedUrlsForMultipartPartsRequest?: UploadsGeneratePresignedUrlsForMultipartPartsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/uploads/batch-presign-multipart-parts.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: uploadsGeneratePresignedUrlsForMultipartPartsRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/uploads/batch-presign-multipart-parts.json',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(uploadsGeneratePresignedUrlsForMultipartPartsRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Direct external uploads bypass the usual method of creating uploads via the POST /uploads route, and upload directly to an external provider, which by default is S3. This route begins the process, and will return a unique identifier for the external upload as well as a presigned URL which is where the file binary blob should be uploaded to.  Once the upload is complete to the external service, you must call the POST /complete-external-upload route using the unique identifier returned by this route, which will create any required Upload record in the Discourse database and also move file from its temporary location to the final destination in the external storage service.  You must have the correct permissions and CORS settings configured in your external provider. We support AWS S3 as the default. See:  https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.  An external file store must be set up and `enable_direct_s3_uploads` must be set to true for this endpoint to function.  
         * @summary Initiates a direct external upload
         * @param {UploadsInitiateDirectExternalUploadRequest} [uploadsInitiateDirectExternalUploadRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateDirectExternalUpload: async (uploadsInitiateDirectExternalUploadRequest?: UploadsInitiateDirectExternalUploadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/uploads/generate-presigned-put.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: uploadsInitiateDirectExternalUploadRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/uploads/generate-presigned-put.json',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(uploadsInitiateDirectExternalUploadRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UploadsApi - functional programming interface
 * @export
 */
export const UploadsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UploadsApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint aborts the multipart upload initiated with /create-multipart. This should be used when cancelling the upload. It does not matter if parts were already uploaded into the external storage provider.  You must have the correct permissions and CORS settings configured in your external provider. We support AWS S3 as the default. See:  https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.  An external file store must be set up and `enable_direct_s3_uploads` must be set to true for this endpoint to function.  
         * @summary Abort multipart upload
         * @param {UploadsApiAbortMultipartUploadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async abortMultipartUpload(requestParameters: UploadsApiAbortMultipartUploadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadsAbortMultipartUploadResponse>> {
            const uploadsAbortMultipartUploadRequest: UploadsAbortMultipartUploadRequest = {
                external_upload_identifier: requestParameters.external_upload_identifier
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.abortMultipartUpload(uploadsAbortMultipartUploadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Completes an external upload initialized with /get-presigned-put. The file will be moved from its temporary location in external storage to a final destination in the S3 bucket. An Upload record will also be created in the database in most cases.  If a sha1-checksum was provided in the initial request it will also be compared with the uploaded file in storage to make sure the same file was uploaded. The file size will be compared for the same reason.  You must have the correct permissions and CORS settings configured in your external provider. We support AWS S3 as the default. See:  https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.  An external file store must be set up and `enable_direct_s3_uploads` must be set to true for this endpoint to function.  
         * @summary Completes a direct external upload
         * @param {UploadsApiCompleteExternalUploadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeExternalUpload(requestParameters: UploadsApiCompleteExternalUploadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadsCompleteExternalUploadResponse>> {
            const uploadsCompleteExternalUploadRequest: UploadsCompleteExternalUploadRequest = {
                unique_identifier: requestParameters.unique_identifier,
                for_private_message: requestParameters.for_private_message,
                for_site_setting: requestParameters.for_site_setting,
                pasted: requestParameters.pasted
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeExternalUpload(uploadsCompleteExternalUploadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Completes the multipart upload in the external store, and copies the file from its temporary location to its final location in the store. All of the parts must have been uploaded to the external storage provider. An Upload record will be completed in most cases once the file is copied to its final location.  You must have the correct permissions and CORS settings configured in your external provider. We support AWS S3 as the default. See:  https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.  An external file store must be set up and `enable_direct_s3_uploads` must be set to true for this endpoint to function.  
         * @summary Complete multipart upload
         * @param {UploadsApiCompleteMultipartUploadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeMultipartUpload(requestParameters: UploadsApiCompleteMultipartUploadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadsCompleteMultipartUploadResponse>> {
            const uploadsCompleteMultipartUploadRequest: UploadsCompleteMultipartUploadRequest = {
                unique_identifier: requestParameters.unique_identifier,
                parts: requestParameters.parts
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeMultipartUpload(uploadsCompleteMultipartUploadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a multipart upload in the external storage provider, storing a temporary reference to the external upload similar to /get-presigned-put.  You must have the correct permissions and CORS settings configured in your external provider. We support AWS S3 as the default. See:  https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.  An external file store must be set up and `enable_direct_s3_uploads` must be set to true for this endpoint to function.  
         * @summary Creates a multipart external upload
         * @param {UploadsApiCreateMultipartExternalUploadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMultipartExternalUpload(requestParameters: UploadsApiCreateMultipartExternalUploadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadsCreateMultipartExternalUploadResponse>> {
            const uploadsCreateMultipartExternalUploadRequest: UploadsCreateMultipartExternalUploadRequest = {
                upload_type: requestParameters.upload_type,
                file_name: requestParameters.file_name,
                file_size: requestParameters.file_size,
                metadata: requestParameters.metadata
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMultipartExternalUpload(uploadsCreateMultipartExternalUploadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Creates an upload
         * @param {UploadsApiCreateNewUploadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNewUpload(requestParameters: UploadsApiCreateNewUploadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadsCreateNewUploadResponse>> {
            const uploadsCreateNewUploadRequest: UploadsCreateNewUploadRequest = {
                type: requestParameters.type,
                user_id: requestParameters.user_id,
                synchronous: requestParameters.synchronous,
                file: requestParameters.file
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNewUpload(requestParameters.type, requestParameters.userId, requestParameters.synchronous, requestParameters.file, uploadsCreateNewUploadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Multipart uploads are uploaded in chunks or parts to individual presigned URLs, similar to the one generated by /generate-presigned-put. The part numbers provided must be between 1 and 10000. The total number of parts will depend on the chunk size in bytes that you intend to use to upload each chunk. For example a 12MB file may have 2 5MB chunks and a final 2MB chunk, for part numbers 1, 2, and 3.  This endpoint will return a presigned URL for each part number provided, which you can then use to send PUT requests for the binary chunk corresponding to that part. When the part is uploaded, the provider should return an ETag for the part, and this should be stored along with the part number, because this is needed to complete the multipart upload.  You must have the correct permissions and CORS settings configured in your external provider. We support AWS S3 as the default. See:  https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.  An external file store must be set up and `enable_direct_s3_uploads` must be set to true for this endpoint to function.  
         * @summary Generates batches of presigned URLs for multipart parts
         * @param {UploadsApiGeneratePresignedUrlsForMultipartPartsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generatePresignedUrlsForMultipartParts(requestParameters: UploadsApiGeneratePresignedUrlsForMultipartPartsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadsGeneratePresignedUrlsForMultipartPartsResponse>> {
            const uploadsGeneratePresignedUrlsForMultipartPartsRequest: UploadsGeneratePresignedUrlsForMultipartPartsRequest = {
                part_numbers: requestParameters.part_numbers,
                unique_identifier: requestParameters.unique_identifier
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.generatePresignedUrlsForMultipartParts(uploadsGeneratePresignedUrlsForMultipartPartsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Direct external uploads bypass the usual method of creating uploads via the POST /uploads route, and upload directly to an external provider, which by default is S3. This route begins the process, and will return a unique identifier for the external upload as well as a presigned URL which is where the file binary blob should be uploaded to.  Once the upload is complete to the external service, you must call the POST /complete-external-upload route using the unique identifier returned by this route, which will create any required Upload record in the Discourse database and also move file from its temporary location to the final destination in the external storage service.  You must have the correct permissions and CORS settings configured in your external provider. We support AWS S3 as the default. See:  https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.  An external file store must be set up and `enable_direct_s3_uploads` must be set to true for this endpoint to function.  
         * @summary Initiates a direct external upload
         * @param {UploadsApiInitiateDirectExternalUploadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initiateDirectExternalUpload(requestParameters: UploadsApiInitiateDirectExternalUploadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadsInitiateDirectExternalUploadResponse>> {
            const uploadsInitiateDirectExternalUploadRequest: UploadsInitiateDirectExternalUploadRequest = {
                type: requestParameters.type,
                file_name: requestParameters.file_name,
                file_size: requestParameters.file_size,
                metadata: requestParameters.metadata
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.initiateDirectExternalUpload(uploadsInitiateDirectExternalUploadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UploadsApi - factory interface
 * @export
 */
export const UploadsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UploadsApiFp(configuration)
    return {
        /**
         * This endpoint aborts the multipart upload initiated with /create-multipart. This should be used when cancelling the upload. It does not matter if parts were already uploaded into the external storage provider.  You must have the correct permissions and CORS settings configured in your external provider. We support AWS S3 as the default. See:  https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.  An external file store must be set up and `enable_direct_s3_uploads` must be set to true for this endpoint to function.  
         * @summary Abort multipart upload
         * @param {UploadsApiAbortMultipartUploadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        abortMultipartUpload(requestParameters: UploadsApiAbortMultipartUploadRequest, options?: AxiosRequestConfig): AxiosPromise<UploadsAbortMultipartUploadResponse> {
            return localVarFp.abortMultipartUpload(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Completes an external upload initialized with /get-presigned-put. The file will be moved from its temporary location in external storage to a final destination in the S3 bucket. An Upload record will also be created in the database in most cases.  If a sha1-checksum was provided in the initial request it will also be compared with the uploaded file in storage to make sure the same file was uploaded. The file size will be compared for the same reason.  You must have the correct permissions and CORS settings configured in your external provider. We support AWS S3 as the default. See:  https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.  An external file store must be set up and `enable_direct_s3_uploads` must be set to true for this endpoint to function.  
         * @summary Completes a direct external upload
         * @param {UploadsApiCompleteExternalUploadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeExternalUpload(requestParameters: UploadsApiCompleteExternalUploadRequest, options?: AxiosRequestConfig): AxiosPromise<UploadsCompleteExternalUploadResponse> {
            return localVarFp.completeExternalUpload(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Completes the multipart upload in the external store, and copies the file from its temporary location to its final location in the store. All of the parts must have been uploaded to the external storage provider. An Upload record will be completed in most cases once the file is copied to its final location.  You must have the correct permissions and CORS settings configured in your external provider. We support AWS S3 as the default. See:  https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.  An external file store must be set up and `enable_direct_s3_uploads` must be set to true for this endpoint to function.  
         * @summary Complete multipart upload
         * @param {UploadsApiCompleteMultipartUploadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeMultipartUpload(requestParameters: UploadsApiCompleteMultipartUploadRequest, options?: AxiosRequestConfig): AxiosPromise<UploadsCompleteMultipartUploadResponse> {
            return localVarFp.completeMultipartUpload(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a multipart upload in the external storage provider, storing a temporary reference to the external upload similar to /get-presigned-put.  You must have the correct permissions and CORS settings configured in your external provider. We support AWS S3 as the default. See:  https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.  An external file store must be set up and `enable_direct_s3_uploads` must be set to true for this endpoint to function.  
         * @summary Creates a multipart external upload
         * @param {UploadsApiCreateMultipartExternalUploadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMultipartExternalUpload(requestParameters: UploadsApiCreateMultipartExternalUploadRequest, options?: AxiosRequestConfig): AxiosPromise<UploadsCreateMultipartExternalUploadResponse> {
            return localVarFp.createMultipartExternalUpload(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates an upload
         * @param {UploadsApiCreateNewUploadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewUpload(requestParameters: UploadsApiCreateNewUploadRequest, options?: AxiosRequestConfig): AxiosPromise<UploadsCreateNewUploadResponse> {
            return localVarFp.createNewUpload(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Multipart uploads are uploaded in chunks or parts to individual presigned URLs, similar to the one generated by /generate-presigned-put. The part numbers provided must be between 1 and 10000. The total number of parts will depend on the chunk size in bytes that you intend to use to upload each chunk. For example a 12MB file may have 2 5MB chunks and a final 2MB chunk, for part numbers 1, 2, and 3.  This endpoint will return a presigned URL for each part number provided, which you can then use to send PUT requests for the binary chunk corresponding to that part. When the part is uploaded, the provider should return an ETag for the part, and this should be stored along with the part number, because this is needed to complete the multipart upload.  You must have the correct permissions and CORS settings configured in your external provider. We support AWS S3 as the default. See:  https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.  An external file store must be set up and `enable_direct_s3_uploads` must be set to true for this endpoint to function.  
         * @summary Generates batches of presigned URLs for multipart parts
         * @param {UploadsApiGeneratePresignedUrlsForMultipartPartsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generatePresignedUrlsForMultipartParts(requestParameters: UploadsApiGeneratePresignedUrlsForMultipartPartsRequest, options?: AxiosRequestConfig): AxiosPromise<UploadsGeneratePresignedUrlsForMultipartPartsResponse> {
            return localVarFp.generatePresignedUrlsForMultipartParts(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Direct external uploads bypass the usual method of creating uploads via the POST /uploads route, and upload directly to an external provider, which by default is S3. This route begins the process, and will return a unique identifier for the external upload as well as a presigned URL which is where the file binary blob should be uploaded to.  Once the upload is complete to the external service, you must call the POST /complete-external-upload route using the unique identifier returned by this route, which will create any required Upload record in the Discourse database and also move file from its temporary location to the final destination in the external storage service.  You must have the correct permissions and CORS settings configured in your external provider. We support AWS S3 as the default. See:  https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.  An external file store must be set up and `enable_direct_s3_uploads` must be set to true for this endpoint to function.  
         * @summary Initiates a direct external upload
         * @param {UploadsApiInitiateDirectExternalUploadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateDirectExternalUpload(requestParameters: UploadsApiInitiateDirectExternalUploadRequest, options?: AxiosRequestConfig): AxiosPromise<UploadsInitiateDirectExternalUploadResponse> {
            return localVarFp.initiateDirectExternalUpload(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for abortMultipartUpload operation in UploadsApi.
 * @export
 * @interface UploadsApiAbortMultipartUploadRequest
 */
export type UploadsApiAbortMultipartUploadRequest = {
    
} & UploadsAbortMultipartUploadRequest

/**
 * Request parameters for completeExternalUpload operation in UploadsApi.
 * @export
 * @interface UploadsApiCompleteExternalUploadRequest
 */
export type UploadsApiCompleteExternalUploadRequest = {
    
} & UploadsCompleteExternalUploadRequest

/**
 * Request parameters for completeMultipartUpload operation in UploadsApi.
 * @export
 * @interface UploadsApiCompleteMultipartUploadRequest
 */
export type UploadsApiCompleteMultipartUploadRequest = {
    
} & UploadsCompleteMultipartUploadRequest

/**
 * Request parameters for createMultipartExternalUpload operation in UploadsApi.
 * @export
 * @interface UploadsApiCreateMultipartExternalUploadRequest
 */
export type UploadsApiCreateMultipartExternalUploadRequest = {
    
} & UploadsCreateMultipartExternalUploadRequest

/**
 * Request parameters for createNewUpload operation in UploadsApi.
 * @export
 * @interface UploadsApiCreateNewUploadRequest
 */
export type UploadsApiCreateNewUploadRequest = {
    
    /**
    * 
    * @type {string}
    * @memberof UploadsApiCreateNewUpload
    */
    readonly type: string
    
    /**
    * required if uploading an avatar
    * @type {number}
    * @memberof UploadsApiCreateNewUpload
    */
    readonly userId?: number
    
    /**
    * Use this flag to return an id and url
    * @type {boolean}
    * @memberof UploadsApiCreateNewUpload
    */
    readonly synchronous?: boolean
    
    /**
    * 
    * @type {Uint8Array | File | buffer.File}
    * @memberof UploadsApiCreateNewUpload
    */
    readonly file?: Uint8Array | File | buffer.File
    
} & UploadsCreateNewUploadRequest

/**
 * Request parameters for generatePresignedUrlsForMultipartParts operation in UploadsApi.
 * @export
 * @interface UploadsApiGeneratePresignedUrlsForMultipartPartsRequest
 */
export type UploadsApiGeneratePresignedUrlsForMultipartPartsRequest = {
    
} & UploadsGeneratePresignedUrlsForMultipartPartsRequest

/**
 * Request parameters for initiateDirectExternalUpload operation in UploadsApi.
 * @export
 * @interface UploadsApiInitiateDirectExternalUploadRequest
 */
export type UploadsApiInitiateDirectExternalUploadRequest = {
    
} & UploadsInitiateDirectExternalUploadRequest

/**
 * UploadsApiGenerated - object-oriented interface
 * @export
 * @class UploadsApiGenerated
 * @extends {BaseAPI}
 */
export class UploadsApiGenerated extends BaseAPI {
    /**
     * This endpoint aborts the multipart upload initiated with /create-multipart. This should be used when cancelling the upload. It does not matter if parts were already uploaded into the external storage provider.  You must have the correct permissions and CORS settings configured in your external provider. We support AWS S3 as the default. See:  https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.  An external file store must be set up and `enable_direct_s3_uploads` must be set to true for this endpoint to function.  
     * @summary Abort multipart upload
     * @param {UploadsApiAbortMultipartUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadsApiGenerated
     */
    public abortMultipartUpload(requestParameters: UploadsApiAbortMultipartUploadRequest, options?: AxiosRequestConfig) {
        return UploadsApiFp(this.configuration).abortMultipartUpload(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Completes an external upload initialized with /get-presigned-put. The file will be moved from its temporary location in external storage to a final destination in the S3 bucket. An Upload record will also be created in the database in most cases.  If a sha1-checksum was provided in the initial request it will also be compared with the uploaded file in storage to make sure the same file was uploaded. The file size will be compared for the same reason.  You must have the correct permissions and CORS settings configured in your external provider. We support AWS S3 as the default. See:  https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.  An external file store must be set up and `enable_direct_s3_uploads` must be set to true for this endpoint to function.  
     * @summary Completes a direct external upload
     * @param {UploadsApiCompleteExternalUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadsApiGenerated
     */
    public completeExternalUpload(requestParameters: UploadsApiCompleteExternalUploadRequest, options?: AxiosRequestConfig) {
        return UploadsApiFp(this.configuration).completeExternalUpload(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Completes the multipart upload in the external store, and copies the file from its temporary location to its final location in the store. All of the parts must have been uploaded to the external storage provider. An Upload record will be completed in most cases once the file is copied to its final location.  You must have the correct permissions and CORS settings configured in your external provider. We support AWS S3 as the default. See:  https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.  An external file store must be set up and `enable_direct_s3_uploads` must be set to true for this endpoint to function.  
     * @summary Complete multipart upload
     * @param {UploadsApiCompleteMultipartUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadsApiGenerated
     */
    public completeMultipartUpload(requestParameters: UploadsApiCompleteMultipartUploadRequest, options?: AxiosRequestConfig) {
        return UploadsApiFp(this.configuration).completeMultipartUpload(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a multipart upload in the external storage provider, storing a temporary reference to the external upload similar to /get-presigned-put.  You must have the correct permissions and CORS settings configured in your external provider. We support AWS S3 as the default. See:  https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.  An external file store must be set up and `enable_direct_s3_uploads` must be set to true for this endpoint to function.  
     * @summary Creates a multipart external upload
     * @param {UploadsApiCreateMultipartExternalUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadsApiGenerated
     */
    public createMultipartExternalUpload(requestParameters: UploadsApiCreateMultipartExternalUploadRequest, options?: AxiosRequestConfig) {
        return UploadsApiFp(this.configuration).createMultipartExternalUpload(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates an upload
     * @param {UploadsApiCreateNewUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadsApiGenerated
     */
    public createNewUpload(requestParameters: UploadsApiCreateNewUploadRequest, options?: AxiosRequestConfig) {
        return UploadsApiFp(this.configuration).createNewUpload(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Multipart uploads are uploaded in chunks or parts to individual presigned URLs, similar to the one generated by /generate-presigned-put. The part numbers provided must be between 1 and 10000. The total number of parts will depend on the chunk size in bytes that you intend to use to upload each chunk. For example a 12MB file may have 2 5MB chunks and a final 2MB chunk, for part numbers 1, 2, and 3.  This endpoint will return a presigned URL for each part number provided, which you can then use to send PUT requests for the binary chunk corresponding to that part. When the part is uploaded, the provider should return an ETag for the part, and this should be stored along with the part number, because this is needed to complete the multipart upload.  You must have the correct permissions and CORS settings configured in your external provider. We support AWS S3 as the default. See:  https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.  An external file store must be set up and `enable_direct_s3_uploads` must be set to true for this endpoint to function.  
     * @summary Generates batches of presigned URLs for multipart parts
     * @param {UploadsApiGeneratePresignedUrlsForMultipartPartsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadsApiGenerated
     */
    public generatePresignedUrlsForMultipartParts(requestParameters: UploadsApiGeneratePresignedUrlsForMultipartPartsRequest, options?: AxiosRequestConfig) {
        return UploadsApiFp(this.configuration).generatePresignedUrlsForMultipartParts(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Direct external uploads bypass the usual method of creating uploads via the POST /uploads route, and upload directly to an external provider, which by default is S3. This route begins the process, and will return a unique identifier for the external upload as well as a presigned URL which is where the file binary blob should be uploaded to.  Once the upload is complete to the external service, you must call the POST /complete-external-upload route using the unique identifier returned by this route, which will create any required Upload record in the Discourse database and also move file from its temporary location to the final destination in the external storage service.  You must have the correct permissions and CORS settings configured in your external provider. We support AWS S3 as the default. See:  https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.  An external file store must be set up and `enable_direct_s3_uploads` must be set to true for this endpoint to function.  
     * @summary Initiates a direct external upload
     * @param {UploadsApiInitiateDirectExternalUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadsApiGenerated
     */
    public initiateDirectExternalUpload(requestParameters: UploadsApiInitiateDirectExternalUploadRequest, options?: AxiosRequestConfig) {
        return UploadsApiFp(this.configuration).initiateDirectExternalUpload(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
